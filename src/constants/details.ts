import { Detail } from '@/types';
import PNGTechCypress from '../../public/assets/icons/tech-cypress.png';
import PNGTechGa from '../../public/assets/icons/tech-ga.png';
import PNGTechJest from '../../public/assets/icons/tech-jest.png';
import PNGTechRq from '../../public/assets/icons/tech-rq.png';
import PNGTechMsw from '../../public/assets/icons/tech-msw.png';
import PNGTechReact from '../../public/assets/icons/tech-react.png';
import PNGTechTl from '../../public/assets/icons/tech-tl.png';
import PNGTechStory from '../../public/assets/icons/tech-story.png';
import PNGTechStyled from '../../public/assets/icons/tech-styled.png';
import PNGTechTs from '../../public/assets/icons/tech-ts.png';
import PNGTechRecoil from '../../public/assets/icons/tech-recoil.png';
import PNGTechWebpack from '../../public/assets/icons/tech-webpack.png';
import PNGTechZustand from '../../public/assets/icons/tech-zustand.png';
import PNGTechEmotion from '../../public/assets/icons/tech-emotion.png';
import PNGTechVite from '../../public/assets/icons/tech-vite.png';
import PNGTechHtml from '../../public/assets/icons/tech-html.png';
import PNGTechCss from '../../public/assets/icons/tech-css.png';
import PNGTechJs from '../../public/assets/icons/tech-js.png';
import PNGTechNext from '../../public/assets/icons/tech-next.png';
import PNGTechTail from '../../public/assets/icons/tech-tail.png';
import PNGTechSwiper from '../../public/assets/icons/tech-swiper.png';
import PNGTechVercel from '../../public/assets/icons/tech-vercel.png';

import PNGNavPa from '../../public/assets/navigations/pa.png';
import PNGNavMa from '../../public/assets/navigations/ma.png';
import PNGNavMbf1 from '../../public/assets/navigations/mbf-1.png';
import PNGNavMbf2 from '../../public/assets/navigations/mbf-2.png';
import PNGNavMbf4 from '../../public/assets/navigations/mbf-4.png';
import PNGNavMbf5 from '../../public/assets/navigations/mbf-5.png';
import PNGNavMbf6 from '../../public/assets/navigations/mbf-6.png';
import PNGNavMbf7 from '../../public/assets/navigations/mbf-7.png';
import PNGNavMbf8 from '../../public/assets/navigations/mbf-8.png';
import PNGNavMbf9 from '../../public/assets/navigations/mbf-9.png';
import PNGNavMbf10 from '../../public/assets/navigations/mbf-10.png';
import PNGNavMbf11 from '../../public/assets/navigations/mbf-11.png';
import PNGNavCb1 from '../../public/assets/navigations/cb-1.png';
import PNGNavCb2 from '../../public/assets/navigations/cb-2.png';
import PNGNavCb4 from '../../public/assets/navigations/cb-4.png';
import PNGNavCb5 from '../../public/assets/navigations/cb-5.png';
import PNGNavCb6 from '../../public/assets/navigations/cb-6.png';
import PNGNavCb7 from '../../public/assets/navigations/cb-7.png';
import PNGNavSc1 from '../../public/assets/navigations/sc-1.png';
import PNGNavSc2 from '../../public/assets/navigations/sc-2.png';
import PNGNavSc4 from '../../public/assets/navigations/sc-4.png';
import PNGNavSc5 from '../../public/assets/navigations/sc-5.png';
import PNGNavSc6 from '../../public/assets/navigations/sc-6.png';
import PNGNavSc7 from '../../public/assets/navigations/sc-7.png';
import PNGNavMl1 from '../../public/assets/navigations/ml-1.png';
import PNGNavMl2 from '../../public/assets/navigations/ml-2.png';
import PNGNavMl4 from '../../public/assets/navigations/ml-4.png';
import PNGNavMl5 from '../../public/assets/navigations/ml-5.png';
import PNGNavMl6 from '../../public/assets/navigations/ml-6.png';
import PNGNavMl7 from '../../public/assets/navigations/ml-7.png';
import PNGNavMl8 from '../../public/assets/navigations/ml-8.png';
import PNGNavPt1 from '../../public/assets/navigations/pt-1.png';
import PNGNavPt2 from '../../public/assets/navigations/pt-2.png';
import PNGNavPt3 from '../../public/assets/navigations/pt-3.png';
import PNGNavPt4 from '../../public/assets/navigations/pt-4.png';
import PNGNavPt5 from '../../public/assets/navigations/pt-5.png';
import PNGNavPt6 from '../../public/assets/navigations/pt-6.png';
import PNGNavPt7 from '../../public/assets/navigations/pt-7.png';
import PNGNavPt8 from '../../public/assets/navigations/pt-8.png';

import SVGFigmaLogo from '../../public/assets/icons/figma-logo.svg';
import SVGGithubLogoWhite from '../../public/assets/icons/github-logo-white.svg';
import SVGWoowaLogoBig from '../../public/assets/icons/woowa-logo-big.svg';
import SVGPortfolioLogoBig from '../../public/assets/icons/portfolio-logo-big.svg';
import SVGMapBeFineLogoBig from '../../public/assets/icons/mapbefine-logo-big.svg';
import SVGMapBeFineLogo from '../../public/assets/icons/mapbefine-logo.svg';

import PNGMapBeFine from '../../public/assets/mapbefine-landing.png';
import PNGMapBeFineMcBefore from '../../public/assets/projects/mapbefine-mc-before.png';
import PNGMapBeFineMcAfter from '../../public/assets/projects/mapbefine-mc-after.png';
import PNGMapBeFineSwiper1 from '../../public/assets/projects/mapbefine-swiper-1.png';
import PNGMapBeFineSwiper2 from '../../public/assets/projects/mapbefine-swiper-2.png';
import PNGMapBeFineSwiper3 from '../../public/assets/projects/mapbefine-swiper-3.png';
import PNGMapBeFineSwiperPercentage from '../../public/assets/projects/mapbefine-swiper-percentage.png';
import PNGMapBeFineLoading1 from '../../public/assets/projects//mapbefine-loading-1.png';
import PNGMapBeFineLoading2 from '../../public/assets/projects//mapbefine-loading-2.png';
import GIFMapBeFineInteraction from '../../public/assets/projects/mapbefine-interaction.gif';
import GIFMapBeFineResponsive from '../../public/assets/projects/mapbefine-responsive.gif';

import SVGConceptBeLogoBig from '../../public/assets/icons/concept-be-logo-big.svg';
import SVGConceptLogo from '../../public/assets/icons/concept-be-logo.svg';
import PNGConceptBe from '../../public/assets/conceptbe-landing.png';
import GIFConceptBeDebouncing from '../../public/assets/projects/conceptbe-debouncing.gif';
import GIFConceptBeScroll from '../../public/assets/projects/conceptbe-scroll.gif';

import PNGShoppingCart from '../../public/assets/shoppingcart-landing.png';
import PNGShoppingCartMocking from '../../public/assets/projects/shopping-cart-mocking.gif';
import PNGShoppingCartResponsive from '../../public/assets/projects/shopping-cart-responsive.gif';

import PNGMovieList from '../../public/assets/movielist-landing.png';
import PNGMovieListResponsive from '../../public/assets/projects/movie-list-responsive.gif';
import PNGMovieListScroll from '../../public/assets/projects/movie-list-scroll.gif';
import PNGMovieListSkeleton from '../../public/assets/projects/movie-list-skeleton.png';

import PNGPortfolioLanding from '../../public/assets/portfolio-landing.png';
import GIFPortfolioVersion1 from '../../public/assets/projects/portfolio-version-1.gif';
import GIFPortfolioVersion2 from '../../public/assets/projects/portfolio-version-2.gif';
import GIFPortfolioHint1 from '../../public/assets/projects/portfolio-hint-1.gif';
import GIFPortfolioHint2 from '../../public/assets/projects/portfolio-hint-2.gif';
import GIFPortfolioHint3 from '../../public/assets/projects/portfolio-hint-3.gif';
import GIFPortfolioNavigation from '../../public/assets/projects/portfolio-navigation.gif';
import GIFPortfolioScrollRestore from '../../public/assets/projects/portfolio-scroll-restore.gif';

export const DETAIL_LANDING = {
  'map-befine': PNGMapBeFine,
  'concept-be': PNGConceptBe,
  'shopping-cart': PNGShoppingCart,
  'movie-list': PNGMovieList,
  portfolio: PNGPortfolioLanding,
};

export const DETAIL_NAV = {
  'map-befine': [
    PNGNavMbf1,
    PNGNavMbf2,
    PNGNavPa,
    PNGNavMbf4,
    PNGNavMbf5,
    PNGNavMbf6,
    PNGNavMbf7,
    PNGNavMbf8,
    PNGNavMbf9,
    PNGNavMbf10,
    PNGNavMbf11,
  ],
  'concept-be': [
    PNGNavCb1,
    PNGNavCb2,
    PNGNavPa,
    PNGNavCb4,
    PNGNavCb5,
    PNGNavCb6,
    PNGNavCb7,
  ],
  'shopping-cart': [
    PNGNavSc1,
    PNGNavSc2,
    PNGNavMa,
    PNGNavSc4,
    PNGNavSc5,
    PNGNavSc6,
    PNGNavSc7,
  ],
  'movie-list': [
    PNGNavMl1,
    PNGNavMl2,
    PNGNavMa,
    PNGNavMl4,
    PNGNavMl5,
    PNGNavMl6,
    PNGNavMl7,
    PNGNavMl8,
  ],
  portfolio: [
    PNGNavPt1,
    PNGNavPt2,
    PNGNavPt3,
    PNGNavPt4,
    PNGNavPt5,
    PNGNavPt6,
    PNGNavPt7,
    PNGNavPt8,
  ],
};

const DETAILS: Detail = {
  'map-befine': [
    {
      id: 1,
      template: 'title',
      title: '괜찮을지도',
      description: '개인의 관심사를 다양한 지도로 만들고 공유할 수 있는 서비스',
      links: [
        {
          name: 'Service',
          href: 'https://mapbefine.com/',
          svg: SVGMapBeFineLogo,
        },
        {
          name: 'Github',
          href: 'https://github.com/woowacourse-teams/2023-map-befine',
          svg: SVGGithubLogoWhite,
        },
        {
          name: 'Figma',
          href: 'https://www.figma.com/file/xgmKaz4AiIrlctuhCb1avk/map-befine?type=design&node-id=0%3A1&mode=design&t=ZRmgumwgoYJMraPb-1',
          svg: SVGFigmaLogo,
        },
      ],
    },
    {
      id: 2,
      template: 'introduction',
      heading: '프로젝트 개요',
      intro:
        '개인의 관심사를 다양한 지도로 만들고 공유할 수 있는 서비스입니다. 서로 다른 주제의 지도를 한 번에 모아보거나, 마음에 드는 장소만 골라 나만의 지도로 재탄생 시킬 수도 있습니다. 또한 내가 선택한 사람들과 협력하여 지도를 만들 수 있습니다.',
      value:
        '위치 기반으로 다양한 주제의 정보들을 기록하고 공유하면서 기존의 텍스트와 이미지로 느낄 수 없었던 새로운 경험을 전하는 것을 핵심 가치로 삼고 있습니다.',
      contribution:
        '다른 사람과 정보 공유가 제한적인 타 지도 서비스와는 달리, 정보를 공유하고 활용하면서 새로운 가치를 도출해낼 수 있을 것으로 기대합니다.',
      organization: '우아한테크코스',
      date: '23.06 - 23.12',
      member: 'FE: 3명, BE: 4명',
      techs: [
        { image: PNGTechTs, name: 'TypeScript' },
        { image: PNGTechReact, name: 'React' },
        { image: PNGTechZustand, name: 'Zustand' },
        { image: PNGTechRq, name: 'React Query' },
        { image: PNGTechStyled, name: 'Styled Components' },
        { image: PNGTechWebpack, name: 'Webpack' },
        { image: PNGTechStory, name: 'Storybook' },
        { image: PNGTechMsw, name: 'MSW' },
        { image: PNGTechJest, name: 'Jest' },
        { image: PNGTechTl, name: 'Testing Library' },
        { image: PNGTechCypress, name: 'Cypress' },
        { image: PNGTechGa, name: 'Github Actions' },
      ],
    },
    {
      id: 3,
      template: 'separator',
      type: 'separate',
      heading: '프로젝트 활동',
    },
    {
      id: 4,
      template: 'activity',
      heading: '사이드 바와 지도 간 상호작용 기능 및 지도 이벤트 핸들링 구현',
      image: GIFMapBeFineInteraction,
      contents: [
        {
          heading: '요구 사항',
          descriptions: [
            '지도 위 마커를 클릭했을 때 사이드바를 확장하여 세부 정보를 보여줄 수 있도록 해야 했고, 사이드 바의 리스트를 클릭하면 해당 정보의 위치가 지도의 중앙으로 오도록 이동 및 줌 인 시켜야 했습니다. 또한 사이드 바가 확장된 채로 URL 공유 기능이 가능해야 했습니다.',
            '사용자가 지도를 드래그 및 줌 할 때 마커 클러스터링, 마커 동적 렌더링 등 복잡한 연산과 서버와의 통신을 최소한으로 수행해야 했습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'Route State 및 쿼리 파라미터와 React의 State를 결합하여 마커 및 사이드 바 클릭 여부를 확인할 수 있도록 함으로써, 사이드 바와 지도 간 상호작용과 URL 공유를 가능하게 했습니다.',
            '지도 이벤트 핸들링 로직에 디바운싱을 걸어 마지막 이벤트에만 로직을 수행하도록 하여 서버 통신과 연산 비용을 절감하고 효율적으로 지도를 조작할 수 있도록 했습니다.',
          ],
        },
      ],
    },
    {
      id: 5,
      template: 'activity-images',
      heading: '마커 클러스터링과 마커 동적 렌더링 구현',
      images: [PNGMapBeFineMcBefore, PNGMapBeFineMcAfter],
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '수백 개 이상의 마커를 보유한 지도의 경우 마커가 지도를 가려 위치 확인이 어렵고 지도를 조작할 때 버벅대는 문제가 있었습니다.',
            '마커 클러스터링을 도입한 후에도 지도를 최대로 확대한 경우, 마커 클러스터링이 모두 해제되어 지도를 조작할 때 버벅대는 문제가 여전히 남아있었습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            '지도의 줌 레벨에 따라 마커의 지름이 지도 상에서 차지하는 실제 거리를 구하고, 마커 간 겹침 여부를 판단하는 방법으로 마커 클러스터링을 구현했습니다.',
            'T Map API를 활용하여 스크린 사이즈에 해당하는 마커들만 동적으로 렌더링하도록 마커 렌더링 로직을 보완했습니다.',
          ],
        },
        {
          heading: '결과',
          descriptions: [
            '지도의 가시성을 효과적으로 개선하고 27인치 FHD, 75fps 모니터 환경에서 800여 개의 마커를 기준으로 렌더링 프레임을 48fps에서 71fps로 향상시킬 수 있었습니다.',
          ],
        },
      ],
    },
    {
      id: 6,
      template: 'activity-images',
      heading: 'Swiper 라이브러리 구현으로 메인 페이지 UI 개선',
      subHeading: '메인 페이지 UI 변화 과정',
      images: [PNGMapBeFineSwiper1, PNGMapBeFineSwiper2, PNGMapBeFineSwiper3],
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '서비스 초반의 메인 페이지에서는 다른 사람이 만들어 둔 지도를 확인하기에 불편했습니다. 본인의 관심사를 기록하는 사용자가 많을 것이라는 예상에 메인 페이지에서부터 지도를 배치했지만, 실제로는 구경하는 사용자가 더 많아 메인 페이지에서부터 지도를 사용하는 경우가 드물었습니다.',
            '두 번째 이미지처럼 메인 페이지를 업데이트 한 후에는 단조로운 UI로 인해 사용자에게 우선적으로 노출하고자 한 콘텐츠가 잘 전달되지 못하는 문제점이 새롭게 발생했습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            '메인 페이지에서는 다른 사람이 만들어 둔 지도를 확인하는데 집중할 수 있도록 지도를 분리하고, 지도가 필요한 페이지에서 동적으로 지도를 보일 수 있도록 기능을 구현함으로써 첫 번째 문제점을 해결할 수 있었습니다.',
            'Swiper 라이브러리를 구현하여 메인 페이지에 배너, 콘텐츠 조회 섹션을 추가했습니다. 우선적으로 노출하고자 하는 콘텐츠를 메인 페이지 배너에 위치해 배너를 클릭하면 해당 콘텐츠 페이지로 이동할 수 있도록 기능을 구현했습니다.',
          ],
        },
      ],
    },
    {
      id: 7,
      template: 'activity',
      heading: 'Swiper 라이브러리 구현으로 메인 페이지 UI 개선',
      subHeading: 'Swiper 라이브러리 적용 이후 주요 콘텐츠 유입률 변화',
      image: PNGMapBeFineSwiperPercentage,
      contents: [
        {
          heading: 'Swiper 적용 전',
          descriptions: [
            '구현한 Swiper 라이브러리를 적용하기 전에는 목표한 콘텐츠 유입률이 전체 페이지 조회수 5,693회 중 649회로 9.5% 밖에 되지 않았습니다.',
          ],
        },
        {
          heading: 'Swiper 적용 후',
          descriptions: [
            'Swiper 라이브러리를 적용한 후엔 목표한 콘텐츠 유입률이 전체 페이지 조회수 10,807회 중 2,321회로 21.4%를 기록하여, 기존보다 유입률을 약 12% 증가시킬 수 있었습니다.',
            '서비스에 특화 되도록 Swiper 라이브러리를 직접 구현한 덕분에, 팀원들이 이미지 조회 등의 영역을 구현할 때 시간을 절감할 수 있었다는 긍정적인 피드백을 받을 수 있었습니다.',
          ],
        },
      ],
    },
    {
      id: 8,
      template: 'activity-images',
      heading: '번들 사이즈 최적화로 초기 로딩 속도 개선',
      images: [PNGMapBeFineLoading1, PNGMapBeFineLoading2],
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '서비스 기능이 다양해짐에 따라 메인 번들 사이즈가 증가해 초기 로딩 시간이 약 4.4초로 길어져 사용자 경험이 좋지 않았습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'Page 컴포넌트 단위로 Dynamic Import와 React의 Lazy, Suspense를 활용하여 Code Splitting을 진행했습니다.',
          ],
        },
        {
          heading: '결과',
          descriptions: [
            '메인 번들 사이즈를 609KB(Gzip: 141.52KB)에서 455KB(Gzip: 93.22KB)로 약 34% 축소시켜, 메인 페이지 LCP를 4.4초에서 3.0초로 약 1.4초 개선했습니다.',
          ],
        },
      ],
    },
    {
      id: 9,
      template: 'activity',
      heading: 'PC 기반 UI에 태블릿 및 모바일 반응형 대응',
      image: GIFMapBeFineResponsive,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '메인 타겟 환경을 PC로 설정하여 서비스를 개발하였기에 태블릿 및 보바일 환경에서 서비스를 이용하기 어려웠습니다. 또한 걸어다니면서 모바일로 주변 정보를 확인할 수 있으면 좋겠다는 피드백을 다수 받았습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'CSS의 Media Query를 활용하여 페이지 별로 모바일 환경에 맞는 레이아웃을 구현하고, Web API의 MatchMedia를 활용하여 구현한 Swiper 라이브러리의 반응형 레이아웃을 구축했습니다. 이를 통해 PC, 태블릿, 모바일 각각의 환경에 최적의 사용성을 제공할 수 있도록 했습니다.',
          ],
        },
      ],
    },
    {
      id: 10,
      template: 'activity-texts',
      heading: '웹 접근성 적용 및 서비스 UI/UX 설계',
      first: {
        title: '시맨틱 태그 및 웹 접근성, 웹 표준 적용',
        contents: [
          {
            heading: '문제 상황',
            descriptions: [
              '스크린 리더기를 통해 서비스를 이용해 보았을 때, 예측 불가한 요소 포커스, 설명 부족으로 인해 스크린 리더기를 사용하는 사용자가 서비스를 정상적으로 이용하기에는 어려움이 있었습니다.',
              "목표한 브라우저(Chrome, Edge, Safari, Whale, Samsung Mobile)에서 서비스의 모든 플로우가 정상적으로 동작했지만, Safari에서 체크 박스 UI가 너무 작아 '뽑아오기' 기능을 활용하기에 불편했습니다.",
            ],
          },
          {
            heading: '해결 과정',
            descriptions: [
              '시맨틱 태그, aria-label 등을 활용하여 일반 사용자가 컨텐츠를 읽는 순으로 요소 포커스를 수행하고 동시에 컨텐츠에 대한 설명을 사운드로 진행할 수 있도록 했습니다.',
              "목표한 브라우저에서 모두 동일하게 보이는 체크 박스 컴포넌트를 구현하여 Safari에서도 '뽑아오기' 기능을 보다 편리하게 사용할 수 있도록 개선했습니다.",
            ],
          },
        ],
      },
      second: {
        title: 'Figma를 활용한 서비스 전반의 UI/UX 설계',
        contents: [
          {
            heading: '문제 상황',
            descriptions: [
              '디자이너의 부재로 서비스 전반의 UI/UX를 3명의 프론트엔드 팀원들이 나눠서 설계해야 했습니다. 이 경우 프론트엔드 인원들이 개발과 디자인 양쪽에서의 업무를 병행해야 하고, 일관되지 않은 UI/UX로 이어져 사용자 경험에 부정적인 영향을 미칠 우려가 있었습니다.',
            ],
          },
          {
            heading: '해결 과정',
            descriptions: [
              '지난 협업에서 Figma를 사용하여 프로젝트의 유저 플로우를 설계했던 경험을 살려, 주도적으로 프로젝트 전반의 와이어 프레임 및 프로토타입을 구현함으로써 일관된 UI/UX 구축했습니다.',
              '사용자 피드백, 개발 과정에서 리팩토링 등으로 인해 변경사항이 생길 경우, 매 스프린트 별로 이에 대응하여 와이어 프레임 및 프로토타입을 수정하여 제공했습니다.',
            ],
          },
        ],
      },
    },
    {
      id: 11,
      template: 'separator',
      type: 'end',
      heading: '컨셉비 프로젝트',
      link: 'concept-be',
      svg: SVGConceptBeLogoBig,
    },
  ],
  'concept-be': [
    {
      id: 1,
      template: 'title',
      title: '컨셉비',
      description:
        '공모전, 스터디 등을 위한 인원을 구인할 수 있는 모바일 웹 서비스',
      links: [
        {
          name: 'Service',
          href: 'https://conceptbe.kr/',
          svg: SVGConceptLogo,
        },
        {
          name: 'Github',
          href: 'https://github.com/ConceptBe/conceptbe-frontend',
          svg: SVGGithubLogoWhite,
        },
        {
          name: 'Design System',
          href: 'https://github.com/ConceptBe/conceptbe-design-system',
          svg: SVGGithubLogoWhite,
        },
        {
          name: 'Figma',
          href: 'https://www.figma.com/file/ExNUhQLDU6HDROD14k4bXN/%EC%BB%A8%EC%85%89%EB%B9%84_%EB%93%9C%EB%9E%98%ED%94%84%ED%8A%B8?type=design&node-id=0%3A1&mode=design&t=3ffb0AJJm2wTW32s-1',
          svg: SVGFigmaLogo,
        },
      ],
    },
    {
      id: 2,
      template: 'introduction',
      heading: '프로젝트 개요',
      intro:
        '공모전, 스터디 등을 위한 다양한 직군의 팀원을 구인할 수 있는 모바일 웹 서비스입니다. 기존의 프로젝트 구인 서비스는 개발 분야에 치우쳐져 있어 비 개발 분야는 프로젝트 인원 구인이 어렵다는 점을 개선하고자 이 프로젝트를 시작했습니다.',
      value:
        '아이디어를 공유하면서 토론하고 평가할 수 있는 공간을 제공하여, 사용자들 간의 다양한 전문성을 융합해 다채로운 활동을 형성하는데 기여하는 것을 핵심 가치로 삼고 있습니다.',
      contribution:
        '현재는 공모전을 팀원을 구하는 것이 어려운 문제점을 해결하는데 집중하고 있습니다. 컨셉비를 통해 공모전 구인을 보다 간편하게 진행할 수 있도록 기대합니다.',
      organization: '비사이드',
      date: '24.01 - 현재',
      member: 'PM: 2명, PD: 1명, FE: 3명, BE: 4명',
      techs: [
        { image: PNGTechTs, name: 'TypeScript' },
        { image: PNGTechReact, name: 'React' },
        { image: PNGTechRq, name: 'React Query' },
        { image: PNGTechEmotion, name: 'Emotion' },
        { image: PNGTechVite, name: 'Vite' },
        { image: PNGTechStory, name: 'Storybook' },
        { image: PNGTechJest, name: 'Jest' },
        { image: PNGTechTl, name: 'Testing Library' },
      ],
    },
    {
      id: 3,
      template: 'separator',
      type: 'separate',
      heading: '프로젝트 활동',
    },
    {
      id: 4,
      template: 'activity-texts',
      heading: '레거시 코드 개선 및 디자인 시스템 구축',
      first: {
        title: 'React Query 도입 및 레거시 코드 개선',
        contents: [
          {
            heading: '문제 상황',
            descriptions: [
              '여러 명의 개발자가 거쳐가면서 제각각의 코드 컨벤션과 중복 코드로 인해 가독성이 좋지 않았습니다.',
              '컴포넌트 내부에 API 응답에 따른 성공, 로딩, 에러 상태 처리 로직이 모두 위치하여 컴포넌트 책임 분리가 모호했습니다.',
            ],
          },
          {
            heading: '해결 과정',
            descriptions: [
              '프로젝트 전반에 사용될 공통 컴포넌트를 구현 후 이미지, 폰트 등과 함께 디자인 시스템으로 분리하여 중복 코드를 최소화하고 일관된 UI를 보장할 수 있도록 했습니다.',
              'React-Query를 도입하여 useSuspenseQuery와 React의 Suspense를 활용하여 로딩 상태에 대한 코드를 분리하고, ErrorBoundary를 통해 에러 상태에 대한 코드를 중앙화 했습니다. 이를 통해 컴포넌트는 성공 상태에 대한 책임만 갖도록 리팩토링을 진행했습니다.',
            ],
          },
        ],
      },
      second: {
        title: 'Storybook을 활용한 디자인 시스템 구축',
        contents: [
          {
            heading: '문제 상황',
            descriptions: [
              '비 개발 팀원이 구현된 결과물을 검토하려면 프로젝트를 AWS 환경에 배포해야만 했으며, 동일한 컴포넌트의 UI를 반복적으로 검토하는 불편함이 있었습니다.',
              '디자인 시스템을 최초로 배포했을 때 패키지 사이즈가 4.76MB로 너무 무거웠으며, 서비스 초기 로딩 속도가 저하되는 문제가 있었습니다.',
            ],
          },
          {
            heading: '해결 과정',
            descriptions: [
              'Storybook을 활용하여 컴포넌트를 문서화하여 배포함으로써 비 개발 팀원들의 검수 작업을 효율적으로 수행할 수 있도록 했습니다. 또한 Addon 기능을 적극적으로 활용하여 컴포넌트의 다양한 형태를 확인하고 테스트 해볼 수 있는 공간을 제공했습니다.',
              '폰트 최적화와 Vite의 rollupOptions 속성을 활용하여 외부 라이브러리 의존성 목록을 지정했습니다. 이를 통해 4.76MB이던 패키지 사이즈를 2.19MB로 축소시켰고 서비스 LCP를 약 1.6초 개선할 수 있었습니다.',
            ],
          },
        ],
      },
    },
    {
      id: 5,
      template: 'activity',
      heading: '무한 스크롤 기능과 스크롤 제어 로직을 통한 포커싱 기능 구현',
      image: GIFConceptBeScroll,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            "댓글 목록을 한 번에 불러올 경우 로딩 시간이 길어질 것 같았고, 나눠서 불러올 경우 유저가 '더 보기' 버튼을 반복적으로 클릭해야 하는 불편함이 예상되었습니다.",
            '컨셉비는 각 댓글마다 답글 입력창을 생성할 수 있는 형태입니다. 따라서 모바일 환경에서 가상 키보드가 확장될 때 답글 입력창을 가려 사용자가 위치를 조정해야 하는 불편함이 있었습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'InfiniteQuery와 useIntersection을 활용하여, 무한 스크롤 기능을 구현해 추가 동작 없이 댓글 추가 조회를 가능토록 했습니다.',
            'Ref와 브라우저 resize 이벤트를 통해 유저의 키보드 높이를 파악하여 답글 입력창이 키보드 위로 위치하도록 포커싱 기능을 구현했습니다. 또한 PC, Android, iOS 별로 포커싱 기능을 분기하여 환경에 알맞는 사용성을 제공했습니다.',
          ],
        },
      ],
      link: {
        heading: '블로그 포스팅',
        name: '댓글 및 답글 스크롤 포커싱 리팩토링',
        href: 'https://velog.io/@semnil5202/%EB%8C%93%EA%B8%80-%EB%B0%8F-%EB%8B%B5%EA%B8%80-%EC%8A%A4%ED%81%AC%EB%A1%A4-%ED%8F%AC%EC%BB%A4%EC%8B%B1-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81',
      },
    },
    {
      id: 6,
      template: 'activity',
      heading: '제어 컴포넌트와 디바운싱을 활용한 닉네임 유효성 및 중복 검사',
      image: GIFConceptBeDebouncing,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '정책상 닉네임은 필수로 입력해야 하고, 두 글자 미만으로 작성할 수 없으며, 특수문자를 포함할 수 없습니다. 이러한 제약들로 인해 사용자가 제출 버튼을 누른 뒤 잘못 입력한 값에 대한 피드백을 받게 되면 입력했던 값을 다시 수정해야 하는 불편함이 예상되었습니다.',
            '사용자가 본인이 입력한 닉네임이 고유한 값인지 확인하려면 닉네임 중복 확인 버튼을 반복적으로 눌러야하는 불편함이 예상되었습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            '제어 컴포넌트 방식을 활용하여 잘못된 입력값이 발생할 경우 그 즉시 피드백을 주어 수정할 수 있도록 유도했습니다. 또한 Form 내의 Input, Textarea가 많아짐에 따라 중복된 상태 관리 및 유효성 검사 로직을 useField라는 Custom Hook으로 분리해 재사용하여 코드 가독성을 높였습니다.',
            'Ref와 setTimeout 메서드를 활용하여 유저의 입력이 300ms 동안 없을 경우, 자동으로 서버에 중복 검사 요청을 보내는 디바운싱 기능을 구현해 별도의 과정 없이 중복 검사를 수행할 수 있었습니다.',
          ],
        },
      ],
    },
    {
      id: 7,
      template: 'separator',
      type: 'end',
      heading: '장바구니 미션',
      link: 'shopping-cart',
      svg: SVGWoowaLogoBig,
    },
  ],
  'shopping-cart': [
    {
      id: 1,
      template: 'title',
      title: '장바구니',
      description: 'MSW로 장바구니 페이지를 만드는 우아한테크코스 React 미션',
      links: [
        {
          name: 'Deploy',
          href: 'https://semnil5202.github.io/react-shopping-cart/',
          svg: SVGGithubLogoWhite,
        },
        {
          name: 'Github',
          href: 'https://github.com/semnil5202/react-shopping-cart/tree/step2',
          svg: SVGGithubLogoWhite,
        },
      ],
    },
    {
      id: 2,
      template: 'introduction',
      heading: '미션 개요',
      intro:
        'MSW를 사용하여 Mock API를 만들고, 이를 활용하여 장바구니 플로우를 구현한 우아한테크코스 React 미션입니다. 서버 개발이 완료되기 전에 API 로직을 미리 작성해보고 테스트 해볼 수 있다는 점에서 MSW의 활용 가치를 느낄 수 있었습니다.',
      organization: '우아한테크코스',
      date: '23.05',
      member: 'FE: 1명',
      techs: [
        { image: PNGTechTs, name: 'TypeScript' },
        { image: PNGTechReact, name: 'React' },
        { image: PNGTechRecoil, name: 'Recoil' },
        { image: PNGTechStyled, name: 'Styled Components' },
        { image: PNGTechStory, name: 'Storybook' },
        { image: PNGTechMsw, name: 'MSW' },
        { image: PNGTechJest, name: 'Jest' },
        { image: PNGTechTl, name: 'Testing Library' },
      ],
    },
    {
      id: 3,
      template: 'separator',
      type: 'separate',
      heading: '미션 활동',
    },
    {
      id: 4,
      template: 'activity',
      heading: 'MSW를 활용하여 서버 의존성 없이 API 로직 구현',
      image: PNGShoppingCartMocking,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '협업 시 API 관련 로직을 구현하려면 서버 개발의 완료를 기다려야 하는 불편함이 있었습니다. 이로 인해 프론트엔드 개발 주기가 비효율적으로 흘러가 API 요청 상태에 따른 처리 로직이 미흡한 문제가 있었습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'MSW를 사용하여 백엔드 개발이 완료되지 않은 상황에서도 프론트엔드 단에서 독립적으로 개발을 진행할 수 있도록 했습니다. 추후 End Point만 교체하는 것으로 실제 서버와 통신이 가능토록 했습니다.',
          ],
        },
        {
          heading: '배운 점',
          descriptions: [
            'MSW를 활용하면 API 로직을 미리 작성하고 테스트해 볼 수 있어, 로직을 보다 안정적으로 작성할 수 있다는 점에서 그 활용 가치를 이해할 수 있었습니다. 이뿐만 아니라, E2E 테스트를 진행할 때 실제 서버 대신 MSW를 활용하면 응답 시간을 설정할 수 있어 테스트 시간 절약 및 오 테스트 비중을 줄일 수 있었습니다.',
          ],
        },
      ],
    },
    {
      id: 5,
      template: 'activity-texts',
      heading: '다형성 컴포넌트 및 Recoil 전역 상태 관리',
      first: {
        title: '다형성 컴포넌트를 통한 중복 코드 최소화',
        contents: [
          {
            heading: '문제 상황',
            descriptions: [
              '버튼, 텍스트, 레이아웃 등 미션 전반에 유사하게 사용되는 컴포넌트가 자주 중복되었고, 간혹 통일되지 않은 스타일 코드로 인해 UI 일관성을 헤쳤습니다.',
            ],
          },
          {
            heading: '해결 과정',
            descriptions: [
              'Styled-Components를 활용해 다형성 컴포넌트를 구현하고, 미션 전반에 사용되는 공통 컴포넌트를 분리함으로써 컴포넌트 재사용성을 높이고 일관된 UI를 구현할 수 있었습니다.',
            ],
          },
        ],
      },
      second: {
        title: 'Recoil을 활용한 전역 상태 관리',
        contents: [
          {
            heading: '배운 점',
            descriptions: [
              'Recoil Atom 개념에 대해서 이해하고 파생된 상태인 Selector를 활용해 보면서, 기존 React의 Context를 활용한 상태 관리 대비 Recoil의 장점에 대해서 이해할 수 있었습니다.',
              '컴포넌트 내부에 Recoil의 State Setter만 불러올 경우 리렌더링 최적화가 된다는 점을 깨닫고, React memo와 더불어 컴포넌트 리렌더링 최적화를 수행해 볼 수 있었습니다.',
              'Atom Effect를 통해 Atom 상태가 업데이트 될 때, Local Storage 세팅과 같이 수행할 작업들을 명시할 수 있어, useEffect를 사용했을 때보다 컴포넌트 관심사 분리가 수월했습니다.',
            ],
          },
        ],
      },
    },
    {
      id: 6,
      template: 'activity',
      heading: '반응형 웹 적용',
      image: PNGShoppingCartResponsive,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            'PC 환경을 기준으로 미션을 구현했기에 모바일 및 태블릿 환경에서 웹 페이지를 확인하기에는 불편함이 있었습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'CSS Media Query를 활용하여 반응형 웹을 적용함으로써 PC, 태블릿, 모바일 각각의 환경에 적합한 사용성을 제공할 수 있도록 했습니다.',
          ],
        },
      ],
    },
    {
      id: 7,
      template: 'separator',
      type: 'end',
      heading: '무비 리스트 미션',
      link: 'movie-list',
      svg: SVGWoowaLogoBig,
    },
  ],
  'movie-list': [
    {
      id: 1,
      template: 'title',
      title: '무비 리스트',
      description: 'TMDB로 영화 목록을 만드는 우아한테크코스 Vanilla JS 미션',
      links: [
        {
          name: 'Deploy',
          href: 'https://semnil5202.github.io/javascript-movie-review/',
          svg: SVGGithubLogoWhite,
        },
        {
          name: 'Github',
          href: 'https://github.com/semnil5202/javascript-movie-review/tree/step2',
          svg: SVGGithubLogoWhite,
        },
      ],
    },
    {
      id: 2,
      template: 'introduction',
      heading: '미션 개요',
      intro:
        'TMDB API를 활용하여 인기 영화 목록을 확인하고 영화를 검색할 수 있는 우아한테크코스 Vanilla JS 미션입니다. Vanilla JS에서의 상태 관리에 대해서 깊은 고민을 할 수 있게 해주었던 미션입니다. 상태 관리를 위한 Observer 패턴과 컴포넌트 재사용을 위한 Custom Element를 활용하여 웹 페이지를 구현했습니다.',
      organization: '우아한테크코스',
      date: '23.03',
      member: 'FE: 1명',
      techs: [
        { image: PNGTechHtml, name: 'HTML' },
        { image: PNGTechCss, name: 'CSS' },
        { image: PNGTechJs, name: 'JavaScript' },
        { image: PNGTechTs, name: 'TypeScript' },
      ],
    },
    {
      id: 3,
      template: 'separator',
      type: 'separate',
      heading: '미션 활동',
    },
    {
      id: 4,
      template: 'activity-texts',
      heading: 'Observer 패턴과 Custom Element 활용',
      first: {
        title: '도메인 상태에 Observer 패턴 적용',
        contents: [
          {
            heading: '문제 상황',
            descriptions: [
              'React와는 달리 Vanilla JS에서는 공통으로 사용되는 컴포넌트에 기능을 부여하는 것이 까다로웠습니다. 예를 들어, 버튼 컴포넌트를 클릭하면 모달을 열어야 한다고 가정하면 버튼 컴포넌트 내부로 모달을 import 해야 했으며, 이 경우 버튼 컴포넌트의 재사용성이 떨어졌습니다.',
            ],
          },
          {
            heading: '해결 과정',
            descriptions: [
              '도메인 상태에 Observer 패턴을 적용하여 상태가 변하면 그 상태를 구독하고 있던 컴포넌트를 업데이트 할 수 있도록 파이프 라인을 구현했습니다. 이를 통해, 컴포넌트 간 의존 관계를 제거하여 재사용성을 높일 수 있었습니다.',
            ],
          },
        ],
        link: {
          heading: '블로그 포스팅',
          name: 'Observer 패턴으로 상태 변화 감지하기',
          href: 'https://velog.io/@semnil5202/Observer-%ED%8C%A8%ED%84%B4%EC%9C%BC%EB%A1%9C-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94-%EA%B0%90%EC%A7%80%ED%95%98%EA%B8%B0',
        },
      },
      second: {
        title: 'HTMLElement를 상속 받아 Custom Element로 활용',
        contents: [
          {
            heading: '문제 상황',
            descriptions: [
              '컴포넌트 렌더링 시점과 실제 DOM에 컴포넌트가 페인팅 되는 시점이 달라, 컴포넌트에 addEventListener를 통해 이벤트를 추가하기가 까다로웠습니다.',
            ],
          },
          {
            heading: '해결 과정',
            descriptions: [
              'Class로 만들어진 컴포넌트에 HTMLElement를 상속 받아 connectedCallback이란 함수를 활용하여 React의 useEffect 역할을 수행하는 메서드를 작성할 수 있었습니다. 이를 통해, addEventListener를 달기 위한 불필요한 코드를 개선할 수 있었습니다.',
            ],
          },
        ],
      },
    },
    {
      id: 5,
      template: 'activity',
      heading: 'IntersectionObserver를 활용한 무한 스크롤과 Scroll To Top 구현',
      image: PNGMovieListScroll,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            "영화 목록을 추가 조회할 때마다 '더 불러오기'와 같은 버튼을 반복적으로 클릭하다 보니, 페이지를 이용하는데 불편함이 있었습니다.",
            'Header가 고정되지 않고 스크롤 되어 넘어가는 방식이었기 때문에, 스크롤 이후 Header에 위치한 영화 검색 버튼을 사용하려면 다시 최상단까지 스크롤을 진행해야 했습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'IntersectionObserver를 활용하여 사용자가 마지막 영화 포스터까지 스크롤 했을 경우를 감지하여 별도의 액션 없이 추가 조회를 수행할 수 있도록 했습니다.',
            'Window의 ScrollTo 메서드를 사용하여 Scroll To Top 기능을 구현함으로써, 영화 검색을 위한 번거로움을 해결할 수 있었습니다.',
          ],
        },
      ],
    },
    {
      id: 6,
      template: 'activity',
      heading: 'Skeleton UI를 사용하여 로딩 상태에서 사용자 경험 증진',
      image: PNGMovieListSkeleton,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '영화 포스터의 이미지 로딩 시간이 오래 걸려 영화 목록을 조회하는 동안의 사용자 경험이 좋지 않았습니다.',
            '영화 포스터의 이미지를 로딩하는 과정에서 Layout Shift가 발생하여 사용자가 잘못된 조작을 할 우려가 있었습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'Skeleton UI를 도입해 영화 포스터 이미지가 로딩 중임을 사용자가 보다 명확하게 인지할 수 있도록 하고, Layout Shift를 개선하여 CLS 0을 달성했습니다.',
          ],
        },
      ],
    },
    {
      id: 7,
      template: 'activity',
      heading: '반응형 웹 적용 및 Bottom Sheet 동적 적용',
      image: PNGMovieListResponsive,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            'PC 환경을 기준으로 미션을 구현했기에 모바일 및 태블릿 환경에서 웹 페이지를 확인하기에는 불편함이 있었습니다.',
            '모바일 환경에서 Modal이 화면 중앙에 위치하게 될 경우 Modal을 조작하는게 불편했습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'CSS Media Query를 활용하여 반응형 웹을 적용함으로써 PC, 태블릿, 모바일 각각의 환경에 적합한 사용성을 제공할 수 있도록 했습니다.',
            'CSS Media Query를 활용하여 모바일 환경으로 인식되었을 때 Modal의 위치를 하단으로 고정하여 Bottom Sheet 형태로 전환될 수 있도록 했습니다.',
          ],
        },
      ],
    },
    {
      id: 8,
      template: 'separator',
      type: 'end',
      heading: '포트폴리오',
      link: 'portfolio',
      svg: SVGPortfolioLogoBig,
    },
  ],
  portfolio: [
    {
      id: 1,
      template: 'title',
      title: '포트폴리오',
      description: 'Next.js를 활용하여 만든 웹 포트폴리오',
      links: [
        {
          name: 'Github',
          href: 'https://github.com/semnil5202/portfolio',
          svg: SVGGithubLogoWhite,
        },
      ],
    },
    {
      id: 2,
      template: 'introduction',
      heading: '포트폴리오 소개',
      intro:
        'Next.js 14 버전을 사용하여 App Router 방식으로 만든 웹 포트폴리오입니다. 기존 평범한 웹 형식의 포트폴리오에서 Swiper JS를 활용하여 PPT 형식의 포트폴리오를 구현했습니다. 내용은 지속적으로 업데이트 되며, 추후 상수로 관리하고 있는 데이터를 DB에 옮기고 포트폴리오 입력 폼을 구성해볼 예정입니다.',
      date: '24.05 - 현재',
      member: 'FE: 1명',
      techs: [
        { image: PNGTechTs, name: 'TypeScript' },
        { image: PNGTechNext, name: 'Next.js' },
        { image: PNGTechZustand, name: 'Zustand' },
        { image: PNGTechTail, name: 'Tailwind CSS' },
        { image: PNGTechSwiper, name: 'Swiper JS' },
        { image: PNGTechVercel, name: 'Vercel' },
      ],
    },
    {
      id: 3,
      template: 'separator',
      type: 'separate',
      heading: '포트폴리오 특징',
    },
    {
      id: 4,
      template: 'activity-images',
      heading: '평범한 웹 형식에서 PPT 컨셉의 포트폴리오로 재구성',
      images: [GIFPortfolioVersion1, GIFPortfolioVersion2],
      contents: [
        {
          heading: '1.0.0 버전의 포트폴리오',
          descriptions: [
            '기존의 포트폴리오는 평범한 웹 형식의 포트폴리오였습니다. 포트폴리오로서 특색을 느낄 수 없었고, 투박한 레이아웃 형식 때문에 텍스트의 배치가 가로로 넓게 분산되어 가독성이 떨어졌습니다.',
          ],
        },
        {
          heading: '2.0.0 버전의 포트폴리오',
          descriptions: [
            '앞으로 프로젝트를 꾸준히 진행할 계획이며, 활동한 내용을 지속적으로 기록할 예정입니다. 포트폴리오의 특색을 살리고 발표에 사용될 경우까지 고려하여 PPT 형식의 포트폴리오로 업데이트 했습니다.',
            '템플릿 단위로 레이아웃을 구현하여 1.0.0 버전 대비 가독성을 개선하고, Next.js의 동적 라우팅 방식을 활용하여 템플릿 재사용성을 높일 수 있었습니다.',
            'Full Page Scroll 방식을 활용하여 보다 생동감 있고, PPT 미리보기 네비게이션, 힌트 기능 등 편의성 기능들을 추가해 포트폴리오 확인을 편리하게 진행할 수 있도록 했습니다.',
          ],
        },
      ],
    },
    {
      id: 5,
      template: 'activity',
      heading: '프로젝트 페이지 미리보기 네비게이션 구현',
      image: GIFPortfolioNavigation,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            'PPT 형식의 프로젝트 페이지는 Full Pagination을 위해 사용자의 스크롤을 제어하기 때문에 페이지가 많아질수록 스크롤 시간이 비례하여 증가했습니다. 주변 지인들의 피드백을 받아본 결과 원하는 페이지로의 이동까지 시간이 오래 걸려 답답한 느낌을 든다는 의견을 받았습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'Thumb Swiper 기능과 Mouse Enter 이벤트를 활용하여 프로젝트 페이지 구조를 볼 수 있고 해당 페이지로 이동할 수 있는 네비게이션 기능을 구현했습니다. 이를 통해, 사용자가 원하는 페이지를 보다 빠르고 간편하게 이동할 수 있도록 했습니다.',
          ],
        },
      ],
    },
    {
      id: 6,
      template: 'activity-images',
      heading: '가려진 요소를 알려주는 힌트 기능 구현',
      images: [GIFPortfolioHint1, GIFPortfolioHint2, GIFPortfolioHint3],
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '스와이프 영역 및 프로젝트 페이지 네비게이션의 경우 사용자가 액션을 취하기 전까지는 화면에서 보이지 않는 요소가 존재했습니다. 지인의 사용을 지켜본 결과 가려진 요소에 대해서 인지하지 못하고 넘어가는 경우가 자주 발생했습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            'Zustand의 Store를 활용해 사용자의 현재 슬라이드 위치를 파악해 해당 페이지에 가려진 요소가 있고 최초 접속한 경우라면, 가려진 요소의 일부를 화면에 잠시 노출시키는 힌트 기능을 구현했습니다. 이를 통해 사용자가 가려진 요소를 인지하는데 도움이 되도록 했습니다.',
          ],
        },
      ],
    },
    {
      id: 7,
      template: 'activity',
      heading: '메인 페이지로 재진입 시 스크롤 복원 기능 구현',
      image: GIFPortfolioScrollRestore,
      contents: [
        {
          heading: '문제 상황',
          descriptions: [
            '프로젝트 페이지에서 뒤로가기 또는 홈 버튼을 클릭해서 메인 페이지로 재진입 했을 때, 첫 번째 슬라이드로 이동되어 다른 프로젝트를 확인하는데 번거롭다는 피드백을 받았습니다.',
          ],
        },
        {
          heading: '해결 과정',
          descriptions: [
            '메인 페이지는 Swiper를 통해 Full Screen Scroll 방식이 적용되어 있었기 때문에, Next.js에서 기본으로 제공하는 스크롤 복원 기능이 정상적으로 동작하지 않았습니다. Zustand의 Store를 활용해 전역 상태로 유저의 마지막 슬라이드 위치를 관리해 스크롤 복원 기능을 구현했습니다.',
          ],
        },
      ],
    },
    {
      id: 8,
      template: 'separator',
      type: 'end',
      heading: '괜찮을지도 프로젝트',
      link: 'map-befine',
      svg: SVGMapBeFineLogoBig,
    },
  ],
};

export default DETAILS;
